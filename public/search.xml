<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[17年要读的书和学习的技能]]></title>
      <url>http://zhangshengshan.github.io/2016/12/09/17%E5%B9%B4%E8%A6%81%E8%AF%BB%E7%9A%84%E4%B9%A6%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="17年要读的书"><a href="#17年要读的书" class="headerlink" title="17年要读的书"></a>17年要读的书</h1><table>
<thead>
<tr>
<th>书籍名称</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法艺术与信息学竞赛:算法竞赛入门经典(第2版)</td>
<td>提升算法水平，强化C／C++</td>
</tr>
<tr>
<td>算法竞赛入门经典:训练指南</td>
<td>提高算法，训练思维</td>
</tr>
<tr>
<td>自己动手写Java虚拟机</td>
<td>了解JAVA虚拟机原理，提升Golang编程水平</td>
</tr>
<tr>
<td>响应式架构:消息模式Actor实现与Scala、Akka应用集成</td>
<td>学习并发编程、提升Scala编程水平</td>
</tr>
<tr>
<td><a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="external">深度学习中文版</a></td>
<td>学习深度学习，为该项目贡献代码</td>
</tr>
<tr>
<td>分布式实时处理系统：原理、架构与实现</td>
<td>深入理解分布式程序开发，提升C／C++实战能力</td>
</tr>
<tr>
<td>深度学习：21天实战Caffe</td>
<td>实战深度学习，提升C／C++编程水平</td>
</tr>
</tbody>
</table>
<h1 id="17年要学习的技能"><a href="#17年要学习的技能" class="headerlink" title="17年要学习的技能"></a>17年要学习的技能</h1><p>机器学习方向</p>
<ul>
<li>DecisionTree</li>
<li>XgBoost</li>
<li>SVM </li>
<li>AdaBoost</li>
<li>PCA</li>
<li>LogisticRegresion</li>
</ul>
<p>Scala</p>
<ul>
<li>Akka</li>
<li>Actor</li>
</ul>
<p>JAVA</p>
<ul>
<li>Spring SpringMVC MyBatis</li>
<li>SpringBoot</li>
</ul>
<p>Golang</p>
<ul>
<li>Beego</li>
<li>channel基础</li>
</ul>
<p>数学基础</p>
<ul>
<li>线性代数</li>
<li>概率论</li>
</ul>
<p>Spark</p>
<ul>
<li>Spark mlib</li>
<li>streaming(redis/kafka/akka/hbase)</li>
<li>structure streaming</li>
<li>basic rdd</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SparkDataFrameLikeSql]]></title>
      <url>http://zhangshengshan.github.io/2016/12/09/SparkDataFrameLikeSql/</url>
      <content type="html"><![CDATA[<p>The idea of spark Datafame is inspired from dataframe of pandas which is a package of python for computing. On my opinion, dataframe can by prefered by the people who is familiar with SQL or BI developers, for it is easy to learn.</p>
<p>DataFrame could by registered as a table ,then Somebody could explore the the data by using Standard SQL.</p>
<p>However this article will focus on  some dataframe processing method without the help of registering a virtual table, and compared to those common operations in SQL including  SELECT, WHERE, GROUPBY, MIN, MAX, COUNT, SUM ,DISTINCT, ORDERBY, TOP, JOIN and so on</p>
<p>here we make a DataFrame object a by reading a json file<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sc: SparkContext // An existing SparkContext.</span><br><span class="line">val sqlContext = new org.apache.spark.sql.SQLContext(sc)</span><br><span class="line">// this is used to implicitly convert an RDD to a DataFrame.</span><br><span class="line">import sqlContext.implicits._</span><br><span class="line">val a = sqlContext.read.json(&quot;people.json&quot;)</span><br></pre></td></tr></table></figure></p>
<p>and the content of people.json is as below<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;Michael&quot; , &quot;age&quot;:23 ,&quot;depart&quot;:&quot;A&quot;,&quot;salary&quot;:3000 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Dan&quot;     , &quot;age&quot;:23 ,&quot;depart&quot;:&quot;A&quot;,&quot;salary&quot;:3500 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Alex&quot;    , &quot;age&quot;:23 ,&quot;depart&quot;:&quot;A&quot;,&quot;salary&quot;:3600 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Ben&quot;     , &quot;age&quot;:23 ,&quot;depart&quot;:&quot;A&quot;,&quot;salary&quot;:3700 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Andy&quot;    , &quot;age&quot;:30 ,&quot;depart&quot;:&quot;B&quot;,&quot;salary&quot;:4000 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Justin&quot;  , &quot;age&quot;:19 ,&quot;depart&quot;:&quot;A&quot;,&quot;salary&quot;:5000 &#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;Jack&quot;    , &quot;age&quot;:19 ,&quot;depart&quot;:&quot;B&quot;,&quot;salary&quot;:2000 &#125;</span><br></pre></td></tr></table></figure></p>
<p>let us image a as a Table which is stored in a RDS database such as MySQL.</p>
<h2 id="desc"><a href="#desc" class="headerlink" title="desc"></a>desc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc people;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; a.printSchema</span><br><span class="line">root</span><br><span class="line">|-- age: long (nullable = true)</span><br><span class="line">|-- depart: string (nullable = true)</span><br><span class="line">|-- name: string (nullable = true)</span><br><span class="line">|-- salary: long (nullable = true)</span><br></pre></td></tr></table></figure>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from people;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.select(&lt;font color=red&gt;&quot;name&quot;&lt;/font&gt;).show</span><br><span class="line">a.select(&lt;font color=red&gt;$&quot;name&quot;&lt;/font&gt;).show</span><br><span class="line">a.select(&lt;font color=red&gt;a(&quot;name&quot;)&lt;/font&gt;).show</span><br></pre></td></tr></table></figure>
<p>the three methods above are equivelent.</p>
<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age from people where age = 23</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.select(&quot;name&quot;, &quot;age&quot;).&lt;font color=red&gt;where&lt;/font&gt;($&quot;age&quot;===23).show</span><br><span class="line">a.select(&quot;name&quot;, &quot;age&quot;).&lt;font color=red&gt;filter&lt;/font&gt;($&quot;age&quot;===23).show</span><br></pre></td></tr></table></figure>
<h2 id="MIN-MAX-SUM"><a href="#MIN-MAX-SUM" class="headerlink" title="MIN,MAX,SUM"></a>MIN,MAX,SUM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(age), max(age), sum(salary) from people</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.select(&lt;font color=red&gt;min&lt;/font&gt;(&quot;age&quot;),&lt;font color=red&gt;max&lt;/font&gt;(&quot;age&quot;),&lt;font color=red&gt;sum&lt;/font&gt;(&quot;salary&quot;),&lt;font color=red&gt;count&lt;/font&gt;(&quot;age&quot;)).show</span><br></pre></td></tr></table></figure>
<p>and the result is<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+--------+--------+-----------+----------+</span><br><span class="line">|min(age)|max(age)|sum(salary)|count(age)|</span><br><span class="line">+--------+--------+-----------+----------+</span><br><span class="line">|      19|      30|      24800|         7|</span><br><span class="line">+--------+--------+-----------+----------+</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[save spark rdd into Mysql]]></title>
      <url>http://zhangshengshan.github.io/2016/12/05/save-spark-rdd-into-Mysql/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Properties</span><br><span class="line">val target_df = targetRdd.toDF()</span><br><span class="line">val prop = new Properties()</span><br><span class="line">prop.put(&quot;user&quot;, &quot;username&quot;)</span><br><span class="line">prop.put(&quot;password&quot;, &quot;password&quot;)</span><br><span class="line">ret_df.write.mode(&quot;append&quot;).jdbc(&quot;jdbc:mysql://host:port/database&quot;,&quot;table&quot;,prop)</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SparkStreamLearning]]></title>
      <url>http://zhangshengshan.github.io/2016/11/28/SparkStreamLearning/</url>
      <content type="html"><![CDATA[<h1 id="input-source"><a href="#input-source" class="headerlink" title="input source"></a>input source</h1><p>kafka<br>akka</p>
<h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>redis<br>kafka<br>elasticSearch<br>hive<br>mySql</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MAC访问你DOCKER容器中的WEB页面]]></title>
      <url>http://zhangshengshan.github.io/2016/11/10/MAC%E8%AE%BF%E9%97%AE%E4%BD%A0DOCKER%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84WEB%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>docker run -d -p hostport:dockerport –name your_container_name  your_image_name nginx -g “daemon off;”</p>
<p>the above instruction start a docker nginx application which bind is port dockerport to its host port hostport.<br>usually you can access the nginx service on your host environment by curl the hostport, however in MacOs, ths hostport here<br>is the virtual machine. so when you curl localhost:hostport, you will get no response.</p>
<p>the right way is access the virtual machine responding port. so the ip of virtual machine is needed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ip your_virtual_machine</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl the ip you get:hostport</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Install Caffe on CentOS]]></title>
      <url>http://zhangshengshan.github.io/2016/11/09/Install-Caffe-on-CentOS/</url>
      <content type="html"><![CDATA[<p>尽量不要在CentOS平台上安装Caffe</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spark Window Operation ]]></title>
      <url>http://zhangshengshan.github.io/2016/08/22/Spark-Window-Operation/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spark 2.0 Introduction]]></title>
      <url>http://zhangshengshan.github.io/2016/08/19/Spark-2-0-Introduction/</url>
      <content type="html"><![CDATA[<h1 id="Spark-2-0-MLib-Introduction"><a href="#Spark-2-0-MLib-Introduction" class="headerlink" title="Spark 2.0 MLib Introduction"></a>Spark 2.0 MLib Introduction</h1><p>As of Spark 2.0, the RDD-based APIs in the spark.mllib package have entered maintenance mode. The primary Machine Learning API for Spark is now the DataFrame-based API in the spark.ml package.</p>
<p>Spark2.0 ,在spark.mllib中的基于RDD的机器学习APIs将会进入维护模式。现在机器学习的主要的API基于DataFrame,位于spark.ml中。</p>
<p>What are the implications?</p>
<pre><code>MLlib will still support the RDD-based API in spark.mllib with bug fixes.
MLlib will not add new features to the RDD-based API.
In the Spark 2.x releases, MLlib will add features to the DataFrames-based API to reach feature parity with the RDD-based API.
After reaching feature parity (roughly estimated for Spark 2.2), the RDD-based API will be deprecated.
The RDD-based API is expected to be removed in Spark 3.0.
</code></pre><p>Why is MLlib switching to the DataFrame-based API?</p>
<pre><code>DataFrames provide a more user-friendly API than RDDs. The many benefits of DataFrames include Spark Datasources, SQL/DataFrame queries, Tungsten and Catalyst optimizations, and uniform APIs across languages.
The DataFrame-based API for MLlib provides a uniform API across ML algorithms and across multiple languages.
DataFrames facilitate practical ML Pipelines, particularly feature transformations. See the Pipelines guide for details.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Save DataFrame into a partitioned table of HIVE]]></title>
      <url>http://zhangshengshan.github.io/2016/08/19/Save-DataFrame-into-a-partitioned-table-of-HIVE/</url>
      <content type="html"><![CDATA[<h1 id="How-to-save-a-spark-DataFrame-as-a-patitioned-hive-table"><a href="#How-to-save-a-spark-DataFrame-as-a-patitioned-hive-table" class="headerlink" title="How to save a spark DataFrame as a patitioned hive table"></a>How to save a spark DataFrame as a patitioned hive table</h1><h2 id="utilise-saveAsTable-method"><a href="#utilise-saveAsTable-method" class="headerlink" title="utilise saveAsTable method"></a>utilise saveAsTable method</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setAppName(&quot;Simple Application&quot;).setMaster(&quot;local&quot;)</span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line">val sqlContext = new org.apache.spark.sql.SQLContext(sc)</span><br><span class="line">import sqlContext.implicits._</span><br><span class="line">val hiveContext = new org.apache.spark.sql.hive.HiveContext(sc)</span><br><span class="line">hiveContext.sql(&quot;use database&quot;)</span><br><span class="line"></span><br><span class="line">val cmd =</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">     select</span><br><span class="line">      col1,</span><br><span class="line">      col2</span><br><span class="line">     from</span><br><span class="line">      table</span><br><span class="line">  &quot;&quot;&quot;.stripMargin</span><br><span class="line">val yourDf = hiveContext.sql(cmd)</span><br><span class="line">yourDf.printSchema()</span><br><span class="line">yourDf.write.partitionBy(&quot;col2&quot;).saveAsTable(&quot;partitionTableName&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SparkPassFunctions]]></title>
      <url>http://zhangshengshan.github.io/2016/08/11/SparkPassFunctions/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  val field = &quot;Hello&quot;</span><br><span class="line">  def doStuff(rdd: RDD[String]): RDD[String] = &#123;</span><br><span class="line">  val field_ = this.field</span><br><span class="line">  rdd.map(x =&gt; field_ + x)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MergeSort]]></title>
      <url>http://zhangshengshan.github.io/2016/07/26/MergeSort/</url>
      <content type="html"><![CDATA[<p>归并排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def msort[A](less: (A, A) =&gt; Boolean)(xs: List[A]): List[A] = &#123; </span><br><span class="line">    def merge(xs1: List[A], xs2: List[A]): List[A] =</span><br><span class="line">        if (xs1.isEmpty) xs2</span><br><span class="line">        else if (xs2.isEmpty) xs1</span><br><span class="line">        else if (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2) else xs2.head :: merge(xs1, xs2.tail)</span><br><span class="line">    val n = xs.length/2</span><br><span class="line">    if (n == 0) xs</span><br><span class="line">    else merge(msort(less)(xs take n), msort(less)(xs drop n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对python列表的用法比较熟悉的话，可以按照如下的方式理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xs take n   // xs[0:n+1]</span><br><span class="line">xs drop n   // xs[n+1:]</span><br></pre></td></tr></table></figure>
<p>msort函数应该按照如下方式进行调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 1, 3))</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ScalaList]]></title>
      <url>http://zhangshengshan.github.io/2016/07/26/ScalaList/</url>
      <content type="html"><![CDATA[<p>Lists are not built in in Scala; they are defined by an abstract class List, <strong>which comes with two subclasses for :: and Nil.</strong><br>List 并不是Scala的内置类型。List被定义为抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package scala</span><br><span class="line">abstract class List[+A] &#123;</span><br></pre></td></tr></table></figure>
<p>List is an abstract class, so one cannot define elements by calling the empty List constructor (e.g. by new List). The class has a type parameter a. It is co-variant in this parameter,which means thatList[S] &lt;: List[T] for all types S and T such thatS &lt;: T.The class is situated in the package scala.This is a package containing the most important standard classes of Scala. List defines a number of methods, which are explained in the following.<br>List 是抽象类，所以没有办法通过空的List构造器来定义元素。List存在一个类型参数A。该参数是协变类型, 对于任意类型S和T，如果S&lt;:T, 则 List[S]&lt;:List[T]。该类的定义在scala package中。这个包是Scala中最重要的标准calsses。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala call-by-name call-by-value]]></title>
      <url>http://zhangshengshan.github.io/2016/07/19/Scala-call-by-name-call-by-value/</url>
      <content type="html"><![CDATA[<p>Call-by-value has the advantage that it avoids repeated evaluation of arguments.<br>Call-by-name has the advantage that it avoids evaluation of arguments when the<br>parameter is not used at all by the function. Call-by-value is usually more efficient<br>than call-by-name, but a call-by-value evaluation might loop where a call-by-name<br>evaluation would terminate. Consider:</p>
<p>Call-by-value 的优势在于避免不断的计算参数。而call-by-name的优势在于如果一个函数根本就不会用到的参数，那么也不会被计算，与call-by-value恰好相反。下面的例子展示了一个Call-by-value会不停循环但是Call-by-name会停止的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def loop: Int = loop</span><br><span class="line">loop: Int</span><br><span class="line">scala&gt; def first(x: Int, y: Int) = x</span><br><span class="line">first: (Int,Int)Int</span><br></pre></td></tr></table></figure>
<p>Then first(1, loop) reduces with call-by-name to 1, whereas the same term reduces with call-by-value repeatedly to itself, hence evaluation does not terminate.<br>first(1, loop)<br>→ first(1, loop)<br>→ first(1, loop)<br>→ …<br>上面的例子，之所以不停的循环的原因就是,y 被声明为 Call-by-value，因而，按照上面的说法，无论是否这个参数会被用到，该参数都会被计算，所以会不停的循环。</p>
<p>Scala uses call-by-value by default, but it switches to call-by-name evaluation if the<br>parameter type is preceded by =&gt;.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def constOne(x: Int, y: =&gt; Int) = 1</span><br><span class="line">constOne: (Int,=&gt; Int)Int</span><br><span class="line">scala&gt; constOne(1, loop)</span><br><span class="line">unnamed0: Int = 1</span><br><span class="line">scala&gt; constOne(loop, 2) // gives an infinite loop.</span><br></pre></td></tr></table></figure></p>
<p>constOne(1,loop) 会停止，y被声明为Call-by-name, 所以当没有用到这个参数的时候,则不会被计算，因此不会陷入无限循环。<br>constOne(loop,2) 则恰好相反。</p>
<p>本文示例 来自于  《ScalaByExample》,感谢原作者。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[机器学习相关材料]]></title>
      <url>http://zhangshengshan.github.io/2016/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%9D%90%E6%96%99/</url>
      <content type="html"><![CDATA[<p>1、数学基础</p>
<ul>
<li>1、微积分 <a href="http://v.163.com/special/sp/singlevariablecalculus.html" target="_blank" rel="external">http://v.163.com/special/sp/singlevariablecalculus.html</a>  <a href="http://open.163.com/special/opencourse/multivariable.html" target="_blank" rel="external">http://open.163.com/special/opencourse/multivariable.html</a></li>
<li>2、线性代数 <a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="external">http://open.163.com/special/opencourse/daishu.html</a></li>
<li>3、概率统计<a href="http://open.163.com/special/Khan/probability.html" target="_blank" rel="external">http://open.163.com/special/Khan/probability.html</a><br>想要深入学习机器学习，需要具有扎实的数学基础（矩阵分析和概率统计是基础的理论）</li>
</ul>
<p>2、进阶版本数学基础课程</p>
<ul>
<li>1、最优化理论（重点凸优化理论）  <a href="http://stanford.edu/~boyd/cvxbook/" target="_blank" rel="external">http://stanford.edu/~boyd/cvxbook/</a>   <a href="http://xiaoyc.com/duality-theory-for-optimization/#1-1-lagrangian" target="_blank" rel="external">http://xiaoyc.com/duality-theory-for-optimization/#1-1-lagrangian</a></li>
<li>2、时变函数与泛函分析 <a href="http://ocw.nctu.edu.tw/course_list.php?page=2&amp;bgid=1&amp;gid=1" target="_blank" rel="external">http://ocw.nctu.edu.tw/course_list.php?page=2&amp;bgid=1&amp;gid=1</a>  <a href="http://open.163.com/special/opencourse/fanhanfenxi.html" target="_blank" rel="external">http://open.163.com/special/opencourse/fanhanfenxi.html</a></li>
<li>3、随机过程 Hyperlink: Stochastic Process MIT View the complete course: Discrete Stochastic Processes</li>
</ul>
<p>3、机器学习基础课程</p>
<ul>
<li>1、Coursera上Andrew Ng Andrew Ng的《机器学习》</li>
<li>2、林軒田(国立台湾大学) 機器學習基石</li>
</ul>
<p>4、机器学习基础课程</p>
<ul>
<li>1、 《统计学习方法》李航</li>
<li>2、 《机器学习导论》</li>
<li>3、 《PRML》</li>
<li>4、 《图解机器学习》[日]杉山将</li>
<li>5、   Machine Learning: A Probabilistic Prespective （Kevin Murphy）</li>
<li>6、   Pattern Recognition and Machine Learning （Christopher Bishop）</li>
<li>7、 《Spark机器学习》</li>
<li>8、 《机器学习实战》</li>
<li>9、 《贝叶斯思维:统计建模的Python学习法》</li>
<li>10、Python自然语言处理》</li>
<li>11、数学之美 （吴军）</li>
<li>12、Web智能算法 （Haralambos Marmanis, Dmitry Babenko）</li>
<li>13、集体智慧编程 （Toby Segaran）</li>
<li>14、推荐系统实践</li>
<li>15、计算广告学</li>
</ul>
<p>5、深度学习（注定将成为最近几年的爆发式增长）</p>
<ul>
<li>1、《Deep Learning》<a href="http://www.deeplearningbook.org" target="_blank" rel="external">http://www.deeplearningbook.org</a></li>
<li>2、  CSDN Blog <a href="http://blog.csdn.net/zouxy09/article/details/8775360" target="_blank" rel="external">http://blog.csdn.net/zouxy09/article/details/8775360</a></li>
<li>3、《斯坦福大学深度学习教程》<a href="http://ufldl.stanford.edu/tutorial" target="_blank" rel="external">http://ufldl.stanford.edu/tutorial</a></li>
</ul>
<p>6、 杂项</p>
<ul>
<li>《Choosing a Machine Learning Classifier》</li>
<li>《An Introduction to Deep Learning: From Perceptrons to Deep Networks》 译文：《<a href="http://www.cnblogs.com/xiaowanyer/p/3701944.html》" target="_blank" rel="external">http://www.cnblogs.com/xiaowanyer/p/3701944.html》</a></li>
<li>《The LION Way: Machine Learning plus Intelligent Optimization》</li>
<li>《分布式并行处理的数据》</li>
<li>《Deep Learning for Natural Language Processing and Related Applications》</li>
<li>《Neural Networks and Deep Learning》</li>
<li>《分布式机器学习的故事》</li>
<li>《Deep Learning 101》</li>
<li>《Deep learning from the bottom up》</li>
<li>《Deep Learning（深度学习）学习笔记整理系列》</li>
<li>《Google Turns To Deep Learning Classification To Fight Web Spam》</li>
<li>《Deep Learning Sentiment Analysis for Movie Reviews using Neo4j》</li>
<li>《EMNLP上两篇关于股票趋势的应用论文 》</li>
<li>《Learning to Rank for Information Retrieval and Natural Language Processing》</li>
<li>《Geoffrey E. Hinton》</li>
<li>《Andrej Karpathy的深度强化学习演示》 论文在这里</li>
<li>《用大数据和机器学习做股票价格预测》</li>
<li>《机器学习经典算法详解及Python实现–基于SMO的SVM分类器》</li>
<li>《Use Google’s Word2Vec for movie reviews》</li>
<li>《深度卷积神经网络下围棋》</li>
<li>《机器学习经典算法详解及Python实现–线性回归（Linear Regression）算法》</li>
<li>《Caffe》</li>
<li>《GoogLeNet深度学习模型的Caffe复现 》 GoogleNet论文</li>
<li>《Deep Learning实战之word2vec》</li>
<li>《A Deep Dive into Recurrent Neural Nets》</li>
<li>《Geoffrey E. Hinton个人主页》</li>
<li>《Deep Learning on Hadoop 2.0》</li>
<li>《美团推荐算法实践》</li>
<li>《The Trouble with SVMs》</li>
<li>《Gaussian Processes for Machine Learning》</li>
<li>《Introduction to ARMA Time Series Models – simplified》</li>
<li>《Neural Net in C++ Tutorial》</li>
<li>《Deep Learning Tutorials》</li>
<li>《Deep Learning, The Curse of Dimensionality, and Autoencoders》</li>
<li>《Topic modeling with LDA: MLlib meets GraphX》</li>
<li>《Deep Learning for Multi-label Classification》</li>
<li>《Google DeepMind publications》  AlphaGo团队官方论文</li>
<li>《AM207: Monte Carlo Methods, Stochastic Optimization》</li>
<li>《Back-to-Basics Weekend Reading - Machine Learning》</li>
<li>《A Probabilistic Theory of Deep Learning》</li>
<li>《How does Quora use machine learning in 2015?》</li>
<li>《Parallel Machine Learning with scikit-learn and IPython》</li>
<li>《Time Series Econometrics - A Concise Course》</li>
<li>《A comparison of open source tools for sentiment analysis》</li>
<li>《International Joint Conference on Artificial Intelligence Accepted paper》</li>
<li>《How to Evaluate Machine Learning Models, Part 1: Orientation》 How to Evaluate Machine Learning Models, Part 2a: Classification Metrics,How to Evaluate Machine Learning Models, Part 2b: Ranking and Regression Metrics.</li>
<li>《Learning scikit-learn: Machine Learning in Python》</li>
<li>《Lightning fast Machine Learning with Spark》</li>
<li>《How we’re using machine learning to fight shell selling》</li>
<li>《Mining of Massive Datasets》</li>
<li>《Advances in Extreme Learning Machines》</li>
<li>《The Curse of Dimensionality in classification》</li>
<li>《Demistifying LSTM Neural Networks》</li>
<li>《Decoding Dimensionality Reduction, PCA and SVD》</li>
<li>《What are the advantages of different classification algorithms?》</li>
<li>《Kaggle R Tutorial on Machine Learning》 《Interactive R Tutorial: Machine Learning for the Titanic Competition》.</li>
<li>《Logistic Regression and Gradient Descent》</li>
<li>《Stock Forecasting With Machine Learning - Seven Possible Errors》</li>
<li>《LR原理解析》  <a href="http://www.cnblogs.com/xiaowanyer/p/3701944.html" target="_blank" rel="external">http://www.cnblogs.com/xiaowanyer/p/3701944.html</a></li>
<li>机器学习顶级会议和杂志 <a href="http://icml.cc/2015/?page_id=175" target="_blank" rel="external">http://icml.cc/2015/?page_id=175</a></li>
<li>贝耶斯回归材料 <a href="http://blog.csdn.net/haoni123321/article/details/37913795" target="_blank" rel="external">http://blog.csdn.net/haoni123321/article/details/37913795</a></li>
<li>贝耶斯回归材料 <a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/" target="_blank" rel="external">http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/</a> </li>
<li>AlphaGo原理解析<a href="https://www.youtube.com/watch?v=63FDxJ5e_Ew" target="_blank" rel="external">https://www.youtube.com/watch?v=63FDxJ5e_Ew</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[过拟合的原因]]></title>
      <url>http://zhangshengshan.github.io/2016/07/13/%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      <content type="html"><![CDATA[<h1 id="过拟合产生原因"><a href="#过拟合产生原因" class="headerlink" title="过拟合产生原因"></a>过拟合产生原因</h1><h2 id="观测数据存在误差"><a href="#观测数据存在误差" class="headerlink" title="观测数据存在误差"></a>观测数据存在误差</h2><p>用于训练的样本数据，即观测数据因为各种个样的原因，总会产生误差。如果选择的假设过分追求能够完美解释观测数据（对于回归问题，可能是拟合曲线“穿过”所有的样本点，或者类似于均方误差过小），都有可能造成过拟合的现象。造成这种现象的根本原因在于，拟合曲线把误差也完美的学习了。</p>
<h2 id="产生样本因素很多，但是实际可能只有小部分提取出来"><a href="#产生样本因素很多，但是实际可能只有小部分提取出来" class="headerlink" title="产生样本因素很多，但是实际可能只有小部分提取出来"></a>产生样本因素很多，但是实际可能只有小部分提取出来</h2><p>影响产生观测数据的因素有很多，但是现实中可能仅提取几个和结果相关度很高的因素来进行分析。这个时候观察数据会倾向于围绕你的有限模型的预测结果呈正态分布，于是你实际观察到的结果就是这个正态分布的随机取样，这个取样很可能受到其余因素的影响偏离你的模型所预测的中心，这个时候便不能贪心不足地试图通过改变模型来“完美”匹配数据，因为那些使结果偏离你的预测的贡献因素不是你这个有限模型里面含有的因素所能概括的，硬要打肿脸充胖子只能导致不实际的模型。</p>
<h2 id="奥卡姆剃刀法则"><a href="#奥卡姆剃刀法则" class="headerlink" title="奥卡姆剃刀法则"></a>奥卡姆剃刀法则</h2><p>$$<br>p\left( h|D\right )   = p\left( h\right ) p\left( D|h\right )<br>$$<br>高卡姆剃刀法则的含义是如果存在多个假设和观察一致，则应当选择最简单的那一个。最简单的假设意味着$\left( h\right)$较大，而与观测一致，意味着似然数值较大，即$p\left( D|h\right )$较大。</p>
<p>奥卡姆剃刀法则青睐于先验概率，认为先验较大的模型有较大的优势；最大似然法则认为似然大的模型具有较大的优势；而贝叶斯法则则认为二者乘积决定模型的选择问题。</p>
<h2 id="贝叶斯奥卡姆剃刀"><a href="#贝叶斯奥卡姆剃刀" class="headerlink" title="贝叶斯奥卡姆剃刀"></a>贝叶斯奥卡姆剃刀</h2><p>上面的奥卡姆剃刀法则描述的是传统的剃刀法则，主要指先验概率$\left( h\right)$,而贝叶斯法奥卡姆剃刀法其实和似然$p\left( D|h\right )$上面，即该法则主要衡量的因素是似然本身出现的概率大小。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SPARK的宽依赖和窄依赖]]></title>
      <url>http://zhangshengshan.github.io/2016/04/25/SPARK%E7%9A%84%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96/</url>
      <content type="html"><![CDATA[<p>spark 的各种不同的transformation操作,可以根据是否依赖父RDDs的所有partision分为‘窄依赖’和‘宽依赖’,简单的说,有shuffle操作的就是宽依赖,而没有shuffle操作的就是窄依赖。<br>对于窄依赖,spark会尽量将他们划分为同一个stage,而宽依赖则会称为另外的stage。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[1-100素数判断pyhon程序]]></title>
      <url>http://zhangshengshan.github.io/2016/04/21/1-100%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%ADpyhon%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>求取1-100的所有素数，采用函数式编程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span><span class="params">(x)</span>:</span></span><br><span class="line">    result=map(<span class="keyword">lambda</span> y:x%y,range(<span class="number">2</span>,x))</span><br><span class="line">    <span class="keyword">if</span>  len(result)!=<span class="number">0</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> filter(issu,range(<span class="number">1</span>,<span class="number">101</span>))</span><br></pre></td></tr></table></figure></p>
<p>答案为<br><strong>[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]</strong></p>
]]></content>
    </entry>
    
  
  
</search>
